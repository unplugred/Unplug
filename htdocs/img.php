<?php
 define("CIMAGE_BUNDLE", true); $config = array( 'mode' => 'strict', ); define("CIMAGE_VERSION", "v0.7.20 (2017-11-06)"); define("CIMAGE_USER_AGENT", "CImage/" . CIMAGE_VERSION); if (!defined("IMG_WEBP")) { define("IMG_WEBP", -1); } function trace($msg) { $file = CIMAGE_DEBUG_FILE; if (!is_writable($file)) { return; } $timer = number_format((microtime(true) - $_SERVER["REQUEST_TIME_FLOAT"]), 6); $details = "{$timer}ms"; $details .= ":" . round(memory_get_peak_usage()/1024/1024, 3) . "MB"; $details .= ":" . count(get_included_files()); file_put_contents($file, "$details:$msg\n", FILE_APPEND); } function errorPage($msg, $type = 500) { global $mode; switch ($type) { case 403: $header = "403 Forbidden"; break; case 404: $header = "404 Not Found"; break; default: $header = "500 Internal Server Error"; } if ($mode == "strict") { $header = "404 Not Found"; } header("HTTP/1.0 $header"); if ($mode == "development") { die("[img.php] $msg"); } error_log("[img.php] $msg"); die("HTTP/1.0 $header"); } function get($key, $default = null) { if (is_array($key)) { foreach ($key as $val) { if (isset($_GET[$val])) { return $_GET[$val]; } } } elseif (isset($_GET[$key])) { return $_GET[$key]; } return $default; } function getDefined($key, $defined, $undefined) { return get($key) === null ? $undefined : $defined; } function getConfig($key, $default) { global $config; return isset($config[$key]) ? $config[$key] : $default; } function verbose($msg = null) { global $verbose, $verboseFile; static $log = array(); if (!($verbose || $verboseFile)) { return; } if (is_null($msg)) { return $log; } $log[] = $msg; } function checkExternalCommand($what, $enabled, $commandString) { $no = $enabled ? null : 'NOT'; $text = "Post processing $what is $no enabled.<br>"; list($command) = explode(" ", $commandString); $no = is_executable($command) ? null : 'NOT'; $text .= "The command for $what is $no an executable.<br>"; return $text; } class CHttpGet { private $request = array(); private $response = array(); public function __construct() { $this->request['header'] = array(); } public function buildUrl($baseUrl, $merge) { $parts = parse_url($baseUrl); $parts = array_merge($parts, $merge); $url = $parts['scheme']; $url .= "://"; $url .= $parts['host']; $url .= isset($parts['port']) ? ":" . $parts['port'] : "" ; $url .= $parts['path']; return $url; } public function setUrl($url) { $parts = parse_url($url); $path = ""; if (isset($parts['path'])) { $pathParts = explode('/', $parts['path']); unset($pathParts[0]); foreach ($pathParts as $value) { $path .= "/" . rawurlencode($value); } } $url = $this->buildUrl($url, array("path" => $path)); $this->request['url'] = $url; return $this; } public function setHeader($field, $value) { $this->request['header'][] = "$field: $value"; return $this; } public function parseHeader() { $rawHeaders = rtrim($this->response['headerRaw'], "\r\n"); $headerGroups = explode("\r\n\r\n", $rawHeaders); $header = explode("\r\n", end($headerGroups)); $output = array(); if ('HTTP' === substr($header[0], 0, 4)) { list($output['version'], $output['status']) = explode(' ', $header[0]); unset($header[0]); } foreach ($header as $entry) { $pos = strpos($entry, ':'); $output[trim(substr($entry, 0, $pos))] = trim(substr($entry, $pos + 1)); } $this->response['header'] = $output; return $this; } public function doGet($debug = false) { $options = array( CURLOPT_URL => $this->request['url'], CURLOPT_HEADER => 1, CURLOPT_HTTPHEADER => $this->request['header'], CURLOPT_AUTOREFERER => true, CURLOPT_RETURNTRANSFER => true, CURLINFO_HEADER_OUT => $debug, CURLOPT_CONNECTTIMEOUT => 5, CURLOPT_TIMEOUT => 5, CURLOPT_FOLLOWLOCATION => true, CURLOPT_MAXREDIRS => 2, ); $ch = curl_init(); curl_setopt_array($ch, $options); $response = curl_exec($ch); if (!$response) { throw new Exception("Failed retrieving url, details follows: " . curl_error($ch)); } $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE); $this->response['headerRaw'] = substr($response, 0, $headerSize); $this->response['body'] = substr($response, $headerSize); $this->parseHeader(); if ($debug) { $info = curl_getinfo($ch); echo "Request header<br><pre>", var_dump($info['request_header']), "</pre>"; echo "Response header (raw)<br><pre>", var_dump($this->response['headerRaw']), "</pre>"; echo "Response header (parsed)<br><pre>", var_dump($this->response['header']), "</pre>"; } curl_close($ch); return true; } public function getStatus() { return isset($this->response['header']['status']) ? (int) $this->response['header']['status'] : null; } public function getLastModified() { return isset($this->response['header']['Last-Modified']) ? strtotime($this->response['header']['Last-Modified']) : null; } public function getContentType() { $type = isset($this->response['header']['Content-Type']) ? $this->response['header']['Content-Type'] : null; return preg_match('#[a-z]+/[a-z]+#', $type) ? $type : null; } public function getDate($default = false) { return isset($this->response['header']['Date']) ? strtotime($this->response['header']['Date']) : $default; } public function getMaxAge($default = false) { $cacheControl = isset($this->response['header']['Cache-Control']) ? $this->response['header']['Cache-Control'] : null; $maxAge = null; if ($cacheControl) { $part = explode('=', $cacheControl); $maxAge = ($part[0] == "max-age") ? (int) $part[1] : null; } if ($maxAge) { return $maxAge; } $expire = isset($this->response['header']['Expires']) ? strtotime($this->response['header']['Expires']) : null; return $expire ? $expire : $default; } public function getBody() { return $this->response['body']; } } class CRemoteImage { private $saveFolder = null; private $useCache = true; private $http; private $status; private $defaultMaxAge = 604800; private $url; private $fileName; private $fileJson; private $cache; public function getStatus() { return $this->status; } public function getDetails() { return $this->cache; } public function setCache($path) { $this->saveFolder = rtrim($path, "/") . "/"; return $this; } public function isCacheWritable() { if (!is_writable($this->saveFolder)) { throw new Exception("Cache folder is not writable for downloaded files."); } return $this; } public function useCache($use = true) { $this->useCache = $use; return $this; } public function setHeaderFields() { $cimageVersion = "CImage"; if (defined("CIMAGE_USER_AGENT")) { $cimageVersion = CIMAGE_USER_AGENT; } $this->http->setHeader("User-Agent", "$cimageVersion (PHP/". phpversion() . " cURL)"); $this->http->setHeader("Accept", "image/jpeg,image/png,image/gif"); if ($this->useCache) { $this->http->setHeader("Cache-Control", "max-age=0"); } else { $this->http->setHeader("Cache-Control", "no-cache"); $this->http->setHeader("Pragma", "no-cache"); } } public function save() { $this->cache = array(); $date = $this->http->getDate(time()); $maxAge = $this->http->getMaxAge($this->defaultMaxAge); $lastModified = $this->http->getLastModified(); $type = $this->http->getContentType(); $this->cache['Date'] = gmdate("D, d M Y H:i:s T", $date); $this->cache['Max-Age'] = $maxAge; $this->cache['Content-Type'] = $type; $this->cache['Url'] = $this->url; if ($lastModified) { $this->cache['Last-Modified'] = gmdate("D, d M Y H:i:s T", $lastModified); } $body = $this->http->getBody(); $img = imagecreatefromstring($body); if ($img !== false) { file_put_contents($this->fileName, $body); file_put_contents($this->fileJson, json_encode($this->cache)); return $this->fileName; } return false; } public function updateCacheDetails() { $date = $this->http->getDate(time()); $maxAge = $this->http->getMaxAge($this->defaultMaxAge); $lastModified = $this->http->getLastModified(); $this->cache['Date'] = gmdate("D, d M Y H:i:s T", $date); $this->cache['Max-Age'] = $maxAge; if ($lastModified) { $this->cache['Last-Modified'] = gmdate("D, d M Y H:i:s T", $lastModified); } file_put_contents($this->fileJson, json_encode($this->cache)); return $this->fileName; } public function download($url) { $this->http = new CHttpGet(); $this->url = $url; $this->loadCacheDetails(); if ($this->useCache) { $src = $this->getCachedSource(); if ($src) { $this->status = 1; return $src; } } $this->setHeaderFields(); $this->http->setUrl($this->url); $this->http->doGet(); $this->status = $this->http->getStatus(); if ($this->status === 200) { $this->isCacheWritable(); return $this->save(); } elseif ($this->status === 304) { $this->isCacheWritable(); return $this->updateCacheDetails(); } throw new Exception("Unknown statuscode when downloading remote image: " . $this->status); } public function loadCacheDetails() { $cacheFile = md5($this->url); $this->fileName = $this->saveFolder . $cacheFile; $this->fileJson = $this->fileName . ".json"; if (is_readable($this->fileJson)) { $this->cache = json_decode(file_get_contents($this->fileJson), true); } } public function getCachedSource() { $imageExists = is_readable($this->fileName); $date = strtotime($this->cache['Date']); $maxAge = $this->cache['Max-Age']; $now = time(); if ($imageExists && $date + $maxAge > $now) { return $this->fileName; } if ($imageExists && isset($this->cache['Last-Modified'])) { $this->http->setHeader("If-Modified-Since", $this->cache['Last-Modified']); } return false; } } class CWhitelist { private $whitelist = array(); public function set($whitelist = array()) { if (!is_array($whitelist)) { throw new Exception("Whitelist is not of a supported format."); } $this->whitelist = $whitelist; return $this; } public function check($item, $whitelist = null) { if ($whitelist !== null) { $this->set($whitelist); } if (empty($item) or empty($this->whitelist)) { return false; } foreach ($this->whitelist as $regexp) { if (preg_match("#$regexp#", $item)) { return true; } } return false; } } class CAsciiArt { private $characterSet = array( 'one' => "#0XT|:,.' ", 'two' => "@%#*+=-:. ", 'three' => "$@B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1{}[]?-_+~<>i!lI;:,\"^`'. " ); private $characters = null; private $charCount = null; private $scale = null; private $luminanceStrategy = null; public function __construct() { $this->setOptions(); } public function addCharacterSet($key, $value) { $this->characterSet[$key] = $value; return $this; } public function setOptions($options = array()) { $default = array( "characterSet" => 'two', "scale" => 14, "luminanceStrategy" => 3, "customCharacterSet" => null, ); $default = array_merge($default, $options); if (!is_null($default['customCharacterSet'])) { $this->addCharacterSet('custom', $default['customCharacterSet']); $default['characterSet'] = 'custom'; } $this->scale = $default['scale']; $this->characters = $this->characterSet[$default['characterSet']]; $this->charCount = strlen($this->characters); $this->luminanceStrategy = $default['luminanceStrategy']; return $this; } public function createFromFile($filename) { $img = imagecreatefromstring(file_get_contents($filename)); list($width, $height) = getimagesize($filename); $ascii = null; $incY = $this->scale; $incX = $this->scale / 2; for ($y = 0; $y < $height - 1; $y += $incY) { for ($x = 0; $x < $width - 1; $x += $incX) { $toX = min($x + $this->scale / 2, $width - 1); $toY = min($y + $this->scale, $height - 1); $luminance = $this->luminanceAreaAverage($img, $x, $y, $toX, $toY); $ascii .= $this->luminance2character($luminance); } $ascii .= PHP_EOL; } return $ascii; } public function luminanceAreaAverage($img, $x1, $y1, $x2, $y2) { $numPixels = ($x2 - $x1 + 1) * ($y2 - $y1 + 1); $luminance = 0; for ($x = $x1; $x <= $x2; $x++) { for ($y = $y1; $y <= $y2; $y++) { $rgb = imagecolorat($img, $x, $y); $red = (($rgb >> 16) & 0xFF); $green = (($rgb >> 8) & 0xFF); $blue = ($rgb & 0xFF); $luminance += $this->getLuminance($red, $green, $blue); } } return $luminance / $numPixels; } public function getLuminance($red, $green, $blue) { switch ($this->luminanceStrategy) { case 1: $luminance = ($red * 0.2126 + $green * 0.7152 + $blue * 0.0722) / 255; break; case 2: $luminance = ($red * 0.299 + $green * 0.587 + $blue * 0.114) / 255; break; case 3: $luminance = sqrt(0.299 * pow($red, 2) + 0.587 * pow($green, 2) + 0.114 * pow($blue, 2)) / 255; break; case 0: default: $luminance = ($red + $green + $blue) / (255 * 3); } return $luminance; } public function luminance2character($luminance) { $position = (int) round($luminance * ($this->charCount - 1)); $char = $this->characters[$position]; return $char; } } class CImage { const PNG_GREYSCALE = 0; const PNG_RGB = 2; const PNG_RGB_PALETTE = 3; const PNG_GREYSCALE_ALPHA = 4; const PNG_RGB_ALPHA = 6; const JPEG_QUALITY_DEFAULT = 60; private $quality; private $useQuality = false; const PNG_COMPRESSION_DEFAULT = -1; private $compress; private $useCompress = false; private $HTTPHeader = array(); private $bgColorDefault = array( 'red' => 0, 'green' => 0, 'blue' => 0, 'alpha' => null, ); private $bgColor; private $saveFolder; private $image; private $imageSrc; private $pathToImage; private $fileType; private $extension; private $outputFormat = null; private $lossy = null; private $verbose = false; private $log = array(); private $palette; private $cacheFileName; private $saveAs; private $pngLossy; private $pngLossyCmd; private $pngFilter; private $pngFilterCmd; private $pngDeflate; private $pngDeflateCmd; private $jpegOptimize; private $jpegOptimizeCmd; private $width; private $height; private $newWidth; private $newWidthOrig; private $newHeight; private $newHeightOrig; private $dpr = 1; const UPSCALE_DEFAULT = true; private $upscale = self::UPSCALE_DEFAULT; public $crop; public $cropOrig; private $convolve; private $convolves = array( 'lighten' => '0,0,0, 0,12,0, 0,0,0, 9, 0', 'darken' => '0,0,0, 0,6,0, 0,0,0, 9, 0', 'sharpen' => '-1,-1,-1, -1,16,-1, -1,-1,-1, 8, 0', 'sharpen-alt' => '0,-1,0, -1,5,-1, 0,-1,0, 1, 0', 'emboss' => '1,1,-1, 1,3,-1, 1,-1,-1, 3, 0', 'emboss-alt' => '-2,-1,0, -1,1,1, 0,1,2, 1, 0', 'blur' => '1,1,1, 1,15,1, 1,1,1, 23, 0', 'gblur' => '1,2,1, 2,4,2, 1,2,1, 16, 0', 'edge' => '-1,-1,-1, -1,8,-1, -1,-1,-1, 9, 0', 'edge-alt' => '0,1,0, 1,-4,1, 0,1,0, 1, 0', 'draw' => '0,-1,0, -1,5,-1, 0,-1,0, 0, 0', 'mean' => '1,1,1, 1,1,1, 1,1,1, 9, 0', 'motion' => '1,0,0, 0,1,0, 0,0,1, 3, 0', ); private $fillToFit; private $scale; private $rotateBefore; private $rotateAfter; private $autoRotate; private $sharpen; private $emboss; private $blur; private $offset; private $fillWidth; private $fillHeight; private $allowRemote = false; private $remoteCache; private $remotePattern = '#^https?://#'; private $useCache = true; private $fastTrackCache = null; private $remoteHostWhitelist = null; private $verboseFileName = null; private $asciiOptions = array(); const RESIZE = 1; const RESAMPLE = 2; private $copyStrategy = NULL; public $keepRatio; public $cropToFit; private $cropWidth; private $cropHeight; public $crop_x; public $crop_y; public $filters; private $attr; public function __construct($imageSrc = null, $imageFolder = null, $saveFolder = null, $saveName = null) { $this->setSource($imageSrc, $imageFolder); $this->setTarget($saveFolder, $saveName); } public function injectDependency($property, $object) { if (!property_exists($this, $property)) { $this->raiseError("Injecting unknown property."); } $this->$property = $object; return $this; } public function setVerbose($mode = true) { $this->verbose = $mode; return $this; } public function setSaveFolder($path) { $this->saveFolder = $path; return $this; } public function useCache($use = true) { $this->useCache = $use; return $this; } public function createDummyImage($width = null, $height = null) { $this->newWidth = $this->newWidth ?: $width ?: 100; $this->newHeight = $this->newHeight ?: $height ?: 100; $this->image = $this->CreateImageKeepTransparency($this->newWidth, $this->newHeight); return $this; } public function setRemoteDownload($allow, $cache, $pattern = null) { $this->allowRemote = $allow; $this->remoteCache = $cache; $this->remotePattern = is_null($pattern) ? $this->remotePattern : $pattern; $this->log( "Set remote download to: " . ($this->allowRemote ? "true" : "false") . " using pattern " . $this->remotePattern ); return $this; } public function isRemoteSource($src) { $remote = preg_match($this->remotePattern, $src); $this->log("Detected remote image: " . ($remote ? "true" : "false")); return !!$remote; } public function setRemoteHostWhitelist($whitelist = null) { $this->remoteHostWhitelist = $whitelist; $this->log( "Setting remote host whitelist to: " . (is_null($whitelist) ? "null" : print_r($whitelist, 1)) ); return $this; } public function isRemoteSourceOnWhitelist($src) { if (is_null($this->remoteHostWhitelist)) { $this->log("Remote host on whitelist not configured - allowing."); return true; } $whitelist = new CWhitelist(); $hostname = parse_url($src, PHP_URL_HOST); $allow = $whitelist->check($hostname, $this->remoteHostWhitelist); $this->log( "Remote host is on whitelist: " . ($allow ? "true" : "false") ); return $allow; } private function checkFileExtension($extension) { $valid = array('jpg', 'jpeg', 'png', 'gif', 'webp'); in_array(strtolower($extension), $valid) or $this->raiseError('Not a valid file extension.'); return $this; } private function normalizeFileExtension($extension = null) { $extension = strtolower($extension ? $extension : $this->extension); if ($extension == 'jpeg') { $extension = 'jpg'; } return $extension; } public function downloadRemoteSource($src) { if (!$this->isRemoteSourceOnWhitelist($src)) { throw new Exception("Hostname is not on whitelist for remote sources."); } $remote = new CRemoteImage(); if (!is_writable($this->remoteCache)) { $this->log("The remote cache is not writable."); } $remote->setCache($this->remoteCache); $remote->useCache($this->useCache); $src = $remote->download($src); $this->log("Remote HTTP status: " . $remote->getStatus()); $this->log("Remote item is in local cache: $src"); $this->log("Remote details on cache:" . print_r($remote->getDetails(), true)); return $src; } public function setSource($src, $dir = null) { if (!isset($src)) { $this->imageSrc = null; $this->pathToImage = null; return $this; } if ($this->allowRemote && $this->isRemoteSource($src)) { $src = $this->downloadRemoteSource($src); $dir = null; } if (!isset($dir)) { $dir = dirname($src); $src = basename($src); } $this->imageSrc = ltrim($src, '/'); $imageFolder = rtrim($dir, '/'); $this->pathToImage = $imageFolder . '/' . $this->imageSrc; return $this; } public function setTarget($src = null, $dir = null) { if (!isset($src)) { $this->cacheFileName = null; return $this; } if (isset($dir)) { $this->saveFolder = rtrim($dir, '/'); } $this->cacheFileName = $this->saveFolder . '/' . $src; $this->cacheFileName = preg_replace('/^a-zA-Z0-9\.-_/', '', $this->cacheFileName); $this->log("The cache file name is: " . $this->cacheFileName); return $this; } public function getTarget() { return $this->cacheFileName; } public function setOptions($args) { $this->log("Set new options for processing image."); $defaults = array( 'newWidth' => null, 'newHeight' => null, 'aspectRatio' => null, 'keepRatio' => true, 'cropToFit' => false, 'fillToFit' => null, 'crop' => null, 'area' => null, 'upscale' => self::UPSCALE_DEFAULT, 'useCache' => true, 'useOriginal' => true, 'scale' => null, 'rotateBefore' => null, 'autoRotate' => false, 'bgColor' => null, 'palette' => null, 'filters' => null, 'sharpen' => null, 'emboss' => null, 'blur' => null, 'convolve' => null, 'rotateAfter' => null, 'outputFormat' => null, 'dpr' => 1, 'lossy' => null, ); if (isset($args['crop']) && !is_array($args['crop'])) { $pices = explode(',', $args['crop']); $args['crop'] = array( 'width' => $pices[0], 'height' => $pices[1], 'start_x' => $pices[2], 'start_y' => $pices[3], ); } if (isset($args['area']) && !is_array($args['area'])) { $pices = explode(',', $args['area']); $args['area'] = array( 'top' => $pices[0], 'right' => $pices[1], 'bottom' => $pices[2], 'left' => $pices[3], ); } if (isset($args['filters']) && is_array($args['filters'])) { foreach ($args['filters'] as $key => $filterStr) { $parts = explode(',', $filterStr); $filter = $this->mapFilter($parts[0]); $filter['str'] = $filterStr; for ($i=1; $i<=$filter['argc']; $i++) { if (isset($parts[$i])) { $filter["arg{$i}"] = $parts[$i]; } else { throw new Exception( 'Missing arg to filter, review how many arguments are needed at
                            http://php.net/manual/en/function.imagefilter.php' ); } } $args['filters'][$key] = $filter; } } $args = array_merge($defaults, $args); foreach ($defaults as $key => $val) { $this->{$key} = $args[$key]; } if ($this->bgColor) { $this->setDefaultBackgroundColor($this->bgColor); } $this->newWidthOrig = $this->newWidth; $this->newHeightOrig = $this->newHeight; $this->cropOrig = $this->crop; return $this; } private function mapFilter($name) { $map = array( 'negate' => array('id'=>0, 'argc'=>0, 'type'=>IMG_FILTER_NEGATE), 'grayscale' => array('id'=>1, 'argc'=>0, 'type'=>IMG_FILTER_GRAYSCALE), 'brightness' => array('id'=>2, 'argc'=>1, 'type'=>IMG_FILTER_BRIGHTNESS), 'contrast' => array('id'=>3, 'argc'=>1, 'type'=>IMG_FILTER_CONTRAST), 'colorize' => array('id'=>4, 'argc'=>4, 'type'=>IMG_FILTER_COLORIZE), 'edgedetect' => array('id'=>5, 'argc'=>0, 'type'=>IMG_FILTER_EDGEDETECT), 'emboss' => array('id'=>6, 'argc'=>0, 'type'=>IMG_FILTER_EMBOSS), 'gaussian_blur' => array('id'=>7, 'argc'=>0, 'type'=>IMG_FILTER_GAUSSIAN_BLUR), 'selective_blur' => array('id'=>8, 'argc'=>0, 'type'=>IMG_FILTER_SELECTIVE_BLUR), 'mean_removal' => array('id'=>9, 'argc'=>0, 'type'=>IMG_FILTER_MEAN_REMOVAL), 'smooth' => array('id'=>10, 'argc'=>1, 'type'=>IMG_FILTER_SMOOTH), 'pixelate' => array('id'=>11, 'argc'=>2, 'type'=>IMG_FILTER_PIXELATE), ); if (isset($map[$name])) { return $map[$name]; } else { throw new Exception('No such filter.'); } } public function loadImageDetails($file = null) { $file = $file ? $file : $this->pathToImage; is_readable($file) or $this->raiseError('Image file does not exist.'); $info = list($this->width, $this->height, $this->fileType) = getimagesize($file); if (empty($info)) { $this->fileType = false; if (function_exists("exif_imagetype")) { $this->fileType = exif_imagetype($file); if ($this->fileType === false) { if (function_exists("imagecreatefromwebp")) { $webp = imagecreatefromwebp($file); if ($webp !== false) { $this->width = imagesx($webp); $this->height = imagesy($webp); $this->fileType = IMG_WEBP; } } } } } if (!$this->fileType) { throw new Exception("Loading image details, the file doesn't seem to be a valid image."); } if ($this->verbose) { $this->log("Loading image details for: {$file}"); $this->log(" Image width x height (type): {$this->width} x {$this->height} ({$this->fileType})."); $this->log(" Image filesize: " . filesize($file) . " bytes."); $this->log(" Image mimetype: " . $this->getMimeType()); } return $this; } protected function getMimeType() { if ($this->fileType === IMG_WEBP) { return "image/webp"; } return image_type_to_mime_type($this->fileType); } public function initDimensions() { $this->log("Init dimension (before) newWidth x newHeight is {$this->newWidth} x {$this->newHeight}."); if ($this->newWidth[strlen($this->newWidth)-1] == '%') { $this->newWidth = $this->width * substr($this->newWidth, 0, -1) / 100; $this->log("Setting new width based on % to {$this->newWidth}"); } if ($this->newHeight[strlen($this->newHeight)-1] == '%') { $this->newHeight = $this->height * substr($this->newHeight, 0, -1) / 100; $this->log("Setting new height based on % to {$this->newHeight}"); } is_null($this->aspectRatio) or is_numeric($this->aspectRatio) or $this->raiseError('Aspect ratio out of range'); if ($this->aspectRatio && is_null($this->newWidth) && is_null($this->newHeight)) { if ($this->aspectRatio >= 1) { $this->newWidth = $this->width; $this->newHeight = $this->width / $this->aspectRatio; $this->log("Setting new width & height based on width & aspect ratio (>=1) to (w x h) {$this->newWidth} x {$this->newHeight}"); } else { $this->newHeight = $this->height; $this->newWidth = $this->height * $this->aspectRatio; $this->log("Setting new width & height based on width & aspect ratio (<1) to (w x h) {$this->newWidth} x {$this->newHeight}"); } } elseif ($this->aspectRatio && is_null($this->newWidth)) { $this->newWidth = $this->newHeight * $this->aspectRatio; $this->log("Setting new width based on aspect ratio to {$this->newWidth}"); } elseif ($this->aspectRatio && is_null($this->newHeight)) { $this->newHeight = $this->newWidth / $this->aspectRatio; $this->log("Setting new height based on aspect ratio to {$this->newHeight}"); } if ($this->dpr != 1) { if (!is_null($this->newWidth)) { $this->newWidth = round($this->newWidth * $this->dpr); $this->log("Setting new width based on dpr={$this->dpr} - w={$this->newWidth}"); } if (!is_null($this->newHeight)) { $this->newHeight = round($this->newHeight * $this->dpr); $this->log("Setting new height based on dpr={$this->dpr} - h={$this->newHeight}"); } } is_null($this->newWidth) or is_numeric($this->newWidth) or $this->raiseError('Width not numeric'); is_null($this->newHeight) or is_numeric($this->newHeight) or $this->raiseError('Height not numeric'); $this->log("Init dimension (after) newWidth x newHeight is {$this->newWidth} x {$this->newHeight}."); return $this; } public function calculateNewWidthAndHeight() { $this->log("Calculate new width and height."); $this->log("Original width x height is {$this->width} x {$this->height}."); $this->log("Target dimension (before calculating) newWidth x newHeight is {$this->newWidth} x {$this->newHeight}."); if (isset($this->area)) { $this->offset['top'] = round($this->area['top'] / 100 * $this->height); $this->offset['right'] = round($this->area['right'] / 100 * $this->width); $this->offset['bottom'] = round($this->area['bottom'] / 100 * $this->height); $this->offset['left'] = round($this->area['left'] / 100 * $this->width); $this->offset['width'] = $this->width - $this->offset['left'] - $this->offset['right']; $this->offset['height'] = $this->height - $this->offset['top'] - $this->offset['bottom']; $this->width = $this->offset['width']; $this->height = $this->offset['height']; $this->log("The offset for the area to use is top {$this->area['top']}%, right {$this->area['right']}%, bottom {$this->area['bottom']}%, left {$this->area['left']}%."); $this->log("The offset for the area to use is top {$this->offset['top']}px, right {$this->offset['right']}px, bottom {$this->offset['bottom']}px, left {$this->offset['left']}px, width {$this->offset['width']}px, height {$this->offset['height']}px."); } $width = $this->width; $height = $this->height; if ($this->crop) { $width = $this->crop['width'] = $this->crop['width'] <= 0 ? $this->width + $this->crop['width'] : $this->crop['width']; $height = $this->crop['height'] = $this->crop['height'] <= 0 ? $this->height + $this->crop['height'] : $this->crop['height']; if ($this->crop['start_x'] == 'left') { $this->crop['start_x'] = 0; } elseif ($this->crop['start_x'] == 'right') { $this->crop['start_x'] = $this->width - $width; } elseif ($this->crop['start_x'] == 'center') { $this->crop['start_x'] = round($this->width / 2) - round($width / 2); } if ($this->crop['start_y'] == 'top') { $this->crop['start_y'] = 0; } elseif ($this->crop['start_y'] == 'bottom') { $this->crop['start_y'] = $this->height - $height; } elseif ($this->crop['start_y'] == 'center') { $this->crop['start_y'] = round($this->height / 2) - round($height / 2); } $this->log("Crop area is width {$width}px, height {$height}px, start_x {$this->crop['start_x']}px, start_y {$this->crop['start_y']}px."); } if ($this->keepRatio) { $this->log("Keep aspect ratio."); if (($this->cropToFit || $this->fillToFit) && isset($this->newWidth) && isset($this->newHeight)) { $this->log("Use newWidth and newHeigh as width/height, image should fit in box."); } elseif (isset($this->newWidth) && isset($this->newHeight)) { $ratioWidth = $width / $this->newWidth; $ratioHeight = $height / $this->newHeight; $ratio = ($ratioWidth > $ratioHeight) ? $ratioWidth : $ratioHeight; $this->newWidth = round($width / $ratio); $this->newHeight = round($height / $ratio); $this->log("New width and height was set."); } elseif (isset($this->newWidth)) { $factor = (float)$this->newWidth / (float)$width; $this->newHeight = round($factor * $height); $this->log("New width was set."); } elseif (isset($this->newHeight)) { $factor = (float)$this->newHeight / (float)$height; $this->newWidth = round($factor * $width); $this->log("New height was set."); } else { $this->newWidth = $width; $this->newHeight = $height; } if ($this->cropToFit || $this->fillToFit) { $ratioWidth = $width / $this->newWidth; $ratioHeight = $height / $this->newHeight; if ($this->cropToFit) { $this->log("Crop to fit."); $ratio = ($ratioWidth < $ratioHeight) ? $ratioWidth : $ratioHeight; $this->cropWidth = round($width / $ratio); $this->cropHeight = round($height / $ratio); $this->log("Crop width, height, ratio: $this->cropWidth x $this->cropHeight ($ratio)."); } elseif ($this->fillToFit) { $this->log("Fill to fit."); $ratio = ($ratioWidth < $ratioHeight) ? $ratioHeight : $ratioWidth; $this->fillWidth = round($width / $ratio); $this->fillHeight = round($height / $ratio); $this->log("Fill width, height, ratio: $this->fillWidth x $this->fillHeight ($ratio)."); } } } if ($this->crop) { $this->log("Crop."); $this->newWidth = round(isset($this->newWidth) ? $this->newWidth : $this->crop['width']); $this->newHeight = round(isset($this->newHeight) ? $this->newHeight : $this->crop['height']); } $this->newWidth = round(isset($this->newWidth) ? $this->newWidth : $this->width); $this->newHeight = round(isset($this->newHeight) ? $this->newHeight : $this->height); $this->log("Calculated new width x height as {$this->newWidth} x {$this->newHeight}."); return $this; } public function reCalculateDimensions() { $this->log("Re-calculate image dimensions, newWidth x newHeigh was: " . $this->newWidth . " x " . $this->newHeight); $this->newWidth = $this->newWidthOrig; $this->newHeight = $this->newHeightOrig; $this->crop = $this->cropOrig; $this->initDimensions() ->calculateNewWidthAndHeight(); return $this; } public function setSaveAsExtension($saveAs = null) { if (isset($saveAs)) { $saveAs = strtolower($saveAs); $this->checkFileExtension($saveAs); $this->saveAs = $saveAs; $this->extension = $saveAs; } $this->log("Prepare to save image as: " . $this->extension); return $this; } public function setJpegQuality($quality = null) { if ($quality) { $this->useQuality = true; } $this->quality = isset($quality) ? $quality : self::JPEG_QUALITY_DEFAULT; (is_numeric($this->quality) and $this->quality > 0 and $this->quality <= 100) or $this->raiseError('Quality not in range.'); $this->log("Setting JPEG quality to {$this->quality}."); return $this; } public function setPngCompression($compress = null) { if ($compress) { $this->useCompress = true; } $this->compress = isset($compress) ? $compress : self::PNG_COMPRESSION_DEFAULT; (is_numeric($this->compress) and $this->compress >= -1 and $this->compress <= 9) or $this->raiseError('Quality not in range.'); $this->log("Setting PNG compression level to {$this->compress}."); return $this; } public function useOriginalIfPossible($useOrig = true) { if ($useOrig && ($this->newWidth == $this->width) && ($this->newHeight == $this->height) && !$this->area && !$this->crop && !$this->cropToFit && !$this->fillToFit && !$this->filters && !$this->sharpen && !$this->emboss && !$this->blur && !$this->convolve && !$this->palette && !$this->useQuality && !$this->useCompress && !$this->saveAs && !$this->rotateBefore && !$this->rotateAfter && !$this->autoRotate && !$this->bgColor && ($this->upscale === self::UPSCALE_DEFAULT) && !$this->lossy ) { $this->log("Using original image."); $this->output($this->pathToImage); } return $this; } public function generateFilename($base = null, $useSubdir = true, $prefix = null) { $filename = basename($this->pathToImage); $cropToFit = $this->cropToFit ? '_cf' : null; $fillToFit = $this->fillToFit ? '_ff' : null; $crop_x = $this->crop_x ? "_x{$this->crop_x}" : null; $crop_y = $this->crop_y ? "_y{$this->crop_y}" : null; $scale = $this->scale ? "_s{$this->scale}" : null; $bgColor = $this->bgColor ? "_bgc{$this->bgColor}" : null; $quality = $this->quality ? "_q{$this->quality}" : null; $compress = $this->compress ? "_co{$this->compress}" : null; $rotateBefore = $this->rotateBefore ? "_rb{$this->rotateBefore}" : null; $rotateAfter = $this->rotateAfter ? "_ra{$this->rotateAfter}" : null; $lossy = $this->lossy ? "_l" : null; $saveAs = $this->normalizeFileExtension(); $saveAs = $saveAs ? "_$saveAs" : null; $copyStrat = null; if ($this->copyStrategy === self::RESIZE) { $copyStrat = "_rs"; } $width = $this->newWidth ? '_' . $this->newWidth : null; $height = $this->newHeight ? '_' . $this->newHeight : null; $offset = isset($this->offset) ? '_o' . $this->offset['top'] . '-' . $this->offset['right'] . '-' . $this->offset['bottom'] . '-' . $this->offset['left'] : null; $crop = $this->crop ? '_c' . $this->crop['width'] . '-' . $this->crop['height'] . '-' . $this->crop['start_x'] . '-' . $this->crop['start_y'] : null; $filters = null; if (isset($this->filters)) { foreach ($this->filters as $filter) { if (is_array($filter)) { $filters .= "_f{$filter['id']}"; for ($i=1; $i<=$filter['argc']; $i++) { $filters .= "-".$filter["arg{$i}"]; } } } } $sharpen = $this->sharpen ? 's' : null; $emboss = $this->emboss ? 'e' : null; $blur = $this->blur ? 'b' : null; $palette = $this->palette ? 'p' : null; $autoRotate = $this->autoRotate ? 'ar' : null; $optimize = $this->jpegOptimize ? 'o' : null; $optimize .= $this->pngFilter ? 'f' : null; $optimize .= $this->pngDeflate ? 'd' : null; $convolve = null; if ($this->convolve) { $convolve = '_conv' . preg_replace('/[^a-zA-Z0-9]/', '', $this->convolve); } $upscale = null; if ($this->upscale !== self::UPSCALE_DEFAULT) { $upscale = '_nu'; } $subdir = null; if ($useSubdir === true) { $subdir = str_replace('/', '-', dirname($this->imageSrc)); $subdir = ($subdir == '.') ? '_.' : $subdir; $subdir .= '_'; } $file = $prefix . $subdir . $filename . $width . $height . $offset . $crop . $cropToFit . $fillToFit . $crop_x . $crop_y . $upscale . $quality . $filters . $sharpen . $emboss . $blur . $palette . $optimize . $compress . $scale . $rotateBefore . $rotateAfter . $autoRotate . $bgColor . $convolve . $copyStrat . $lossy . $saveAs; return $this->setTarget($file, $base); } public function useCacheIfPossible($useCache = true) { if ($useCache && is_readable($this->cacheFileName)) { $fileTime = filemtime($this->pathToImage); $cacheTime = filemtime($this->cacheFileName); if ($fileTime <= $cacheTime) { if ($this->useCache) { if ($this->verbose) { $this->log("Use cached file."); $this->log("Cached image filesize: " . filesize($this->cacheFileName) . " bytes."); } $this->output($this->cacheFileName, $this->outputFormat); } else { $this->log("Cache is valid but ignoring it by intention."); } } else { $this->log("Original file is modified, ignoring cache."); } } else { $this->log("Cachefile does not exists or ignoring it."); } return $this; } public function load($src = null, $dir = null) { if (isset($src)) { $this->setSource($src, $dir); } $this->loadImageDetails(); if ($this->fileType === IMG_WEBP) { $this->image = imagecreatefromwebp($this->pathToImage); } else { $imageAsString = file_get_contents($this->pathToImage); $this->image = imagecreatefromstring($imageAsString); } if ($this->image === false) { throw new Exception("Could not load image."); } if ($this->verbose) { $this->log("### Image successfully loaded from file."); $this->log(" imageistruecolor() : " . (imageistruecolor($this->image) ? 'true' : 'false')); $this->log(" imagecolorstotal() : " . imagecolorstotal($this->image)); $this->log(" Number of colors in image = " . $this->colorsTotal($this->image)); $index = imagecolortransparent($this->image); $this->log(" Detected transparent color = " . ($index >= 0 ? implode(", ", imagecolorsforindex($this->image, $index)) : "NONE") . " at index = $index"); } return $this; } public function getPngType($filename = null) { $filename = $filename ? $filename : $this->pathToImage; $pngType = ord(file_get_contents($filename, false, null, 25, 1)); if ($this->verbose) { $this->log("Checking png type of: " . $filename); $this->log($this->getPngTypeAsString($pngType)); } return $pngType; } private function getPngTypeAsString($pngType = null, $filename = null) { if ($filename || !$pngType) { $pngType = $this->getPngType($filename); } $index = imagecolortransparent($this->image); $transparent = null; if ($index != -1) { $transparent = " (transparent)"; } switch ($pngType) { case self::PNG_GREYSCALE: $text = "PNG is type 0, Greyscale$transparent"; break; case self::PNG_RGB: $text = "PNG is type 2, RGB$transparent"; break; case self::PNG_RGB_PALETTE: $text = "PNG is type 3, RGB with palette$transparent"; break; case self::PNG_GREYSCALE_ALPHA: $text = "PNG is type 4, Greyscale with alpha channel"; break; case self::PNG_RGB_ALPHA: $text = "PNG is type 6, RGB with alpha channel (PNG 32-bit)"; break; default: $text = "PNG is UNKNOWN type, is it really a PNG image?"; } return $text; } private function colorsTotal($im) { if (imageistruecolor($im)) { $this->log("Colors as true color."); $h = imagesy($im); $w = imagesx($im); $c = array(); for ($x=0; $x < $w; $x++) { for ($y=0; $y < $h; $y++) { @$c['c'.imagecolorat($im, $x, $y)]++; } } return count($c); } else { $this->log("Colors as palette."); return imagecolorstotal($im); } } public function preResize() { $this->log("### Pre-process before resizing"); if ($this->rotateBefore) { $this->log("Rotating image."); $this->rotate($this->rotateBefore, $this->bgColor) ->reCalculateDimensions(); } if ($this->autoRotate) { $this->log("Auto rotating image."); $this->rotateExif() ->reCalculateDimensions(); } if (isset($this->scale)) { $this->log("Scale by {$this->scale}%"); $newWidth = $this->width * $this->scale / 100; $newHeight = $this->height * $this->scale / 100; $img = $this->CreateImageKeepTransparency($newWidth, $newHeight); imagecopyresampled($img, $this->image, 0, 0, 0, 0, $newWidth, $newHeight, $this->width, $this->height); $this->image = $img; $this->width = $newWidth; $this->height = $newHeight; } return $this; } public function setCopyResizeStrategy($strategy) { $this->copyStrategy = $strategy; return $this; } public function imageCopyResampled($dst_image, $src_image, $dst_x, $dst_y, $src_x, $src_y, $dst_w, $dst_h, $src_w, $src_h) { if($this->copyStrategy == self::RESIZE) { $this->log("Copy by resize"); imagecopyresized($dst_image, $src_image, $dst_x, $dst_y, $src_x, $src_y, $dst_w, $dst_h, $src_w, $src_h); } else { $this->log("Copy by resample"); imagecopyresampled($dst_image, $src_image, $dst_x, $dst_y, $src_x, $src_y, $dst_w, $dst_h, $src_w, $src_h); } } public function resize() { $this->log("### Starting to Resize()"); $this->log("Upscale = '$this->upscale'"); if (isset($this->offset)) { $this->log("Offset for area to use, cropping it width={$this->offset['width']}, height={$this->offset['height']}, start_x={$this->offset['left']}, start_y={$this->offset['top']}"); $img = $this->CreateImageKeepTransparency($this->offset['width'], $this->offset['height']); imagecopy($img, $this->image, 0, 0, $this->offset['left'], $this->offset['top'], $this->offset['width'], $this->offset['height']); $this->image = $img; $this->width = $this->offset['width']; $this->height = $this->offset['height']; } if ($this->crop) { $this->log("Cropping area width={$this->crop['width']}, height={$this->crop['height']}, start_x={$this->crop['start_x']}, start_y={$this->crop['start_y']}"); $img = $this->CreateImageKeepTransparency($this->crop['width'], $this->crop['height']); imagecopy($img, $this->image, 0, 0, $this->crop['start_x'], $this->crop['start_y'], $this->crop['width'], $this->crop['height']); $this->image = $img; $this->width = $this->crop['width']; $this->height = $this->crop['height']; } if (!$this->upscale) { } if ($this->cropToFit) { $this->log("Resizing using strategy - Crop to fit"); if (!$this->upscale && ($this->width < $this->newWidth || $this->height < $this->newHeight)) { $this->log("Resizing - smaller image, do not upscale."); $posX = 0; $posY = 0; $cropX = 0; $cropY = 0; if ($this->newWidth > $this->width) { $posX = round(($this->newWidth - $this->width) / 2); } if ($this->newWidth < $this->width) { $cropX = round(($this->width/2) - ($this->newWidth/2)); } if ($this->newHeight > $this->height) { $posY = round(($this->newHeight - $this->height) / 2); } if ($this->newHeight < $this->height) { $cropY = round(($this->height/2) - ($this->newHeight/2)); } $this->log(" cwidth: $this->cropWidth"); $this->log(" cheight: $this->cropHeight"); $this->log(" nwidth: $this->newWidth"); $this->log(" nheight: $this->newHeight"); $this->log(" width: $this->width"); $this->log(" height: $this->height"); $this->log(" posX: $posX"); $this->log(" posY: $posY"); $this->log(" cropX: $cropX"); $this->log(" cropY: $cropY"); $imageResized = $this->CreateImageKeepTransparency($this->newWidth, $this->newHeight); imagecopy($imageResized, $this->image, $posX, $posY, $cropX, $cropY, $this->width, $this->height); } else { $cropX = round(($this->cropWidth/2) - ($this->newWidth/2)); $cropY = round(($this->cropHeight/2) - ($this->newHeight/2)); $imgPreCrop = $this->CreateImageKeepTransparency($this->cropWidth, $this->cropHeight); $imageResized = $this->CreateImageKeepTransparency($this->newWidth, $this->newHeight); $this->imageCopyResampled($imgPreCrop, $this->image, 0, 0, 0, 0, $this->cropWidth, $this->cropHeight, $this->width, $this->height); imagecopy($imageResized, $imgPreCrop, 0, 0, $cropX, $cropY, $this->newWidth, $this->newHeight); } $this->image = $imageResized; $this->width = $this->newWidth; $this->height = $this->newHeight; } elseif ($this->fillToFit) { $this->log("Resizing using strategy - Fill to fit"); $posX = 0; $posY = 0; $ratioOrig = $this->width / $this->height; $ratioNew = $this->newWidth / $this->newHeight; if ($ratioOrig < $ratioNew) { $posX = round(($this->newWidth - $this->fillWidth) / 2); } else { $posY = round(($this->newHeight - $this->fillHeight) / 2); } if (!$this->upscale && ($this->width < $this->newWidth && $this->height < $this->newHeight) ) { $this->log("Resizing - smaller image, do not upscale."); $posX = round(($this->newWidth - $this->width) / 2); $posY = round(($this->newHeight - $this->height) / 2); $imageResized = $this->CreateImageKeepTransparency($this->newWidth, $this->newHeight); imagecopy($imageResized, $this->image, $posX, $posY, 0, 0, $this->width, $this->height); } else { $imgPreFill = $this->CreateImageKeepTransparency($this->fillWidth, $this->fillHeight); $imageResized = $this->CreateImageKeepTransparency($this->newWidth, $this->newHeight); $this->imageCopyResampled($imgPreFill, $this->image, 0, 0, 0, 0, $this->fillWidth, $this->fillHeight, $this->width, $this->height); imagecopy($imageResized, $imgPreFill, $posX, $posY, 0, 0, $this->fillWidth, $this->fillHeight); } $this->image = $imageResized; $this->width = $this->newWidth; $this->height = $this->newHeight; } elseif (!($this->newWidth == $this->width && $this->newHeight == $this->height)) { $this->log("Resizing, new height and/or width"); if (!$this->upscale && ($this->width < $this->newWidth || $this->height < $this->newHeight) ) { $this->log("Resizing - smaller image, do not upscale."); if (!$this->keepRatio) { $this->log("Resizing - stretch to fit selected."); $posX = 0; $posY = 0; $cropX = 0; $cropY = 0; if ($this->newWidth > $this->width && $this->newHeight > $this->height) { $posX = round(($this->newWidth - $this->width) / 2); $posY = round(($this->newHeight - $this->height) / 2); } elseif ($this->newWidth > $this->width) { $posX = round(($this->newWidth - $this->width) / 2); $cropY = round(($this->height - $this->newHeight) / 2); } elseif ($this->newHeight > $this->height) { $posY = round(($this->newHeight - $this->height) / 2); $cropX = round(($this->width - $this->newWidth) / 2); } $imageResized = $this->CreateImageKeepTransparency($this->newWidth, $this->newHeight); imagecopy($imageResized, $this->image, $posX, $posY, $cropX, $cropY, $this->width, $this->height); $this->image = $imageResized; $this->width = $this->newWidth; $this->height = $this->newHeight; } } else { $imageResized = $this->CreateImageKeepTransparency($this->newWidth, $this->newHeight); $this->imageCopyResampled($imageResized, $this->image, 0, 0, 0, 0, $this->newWidth, $this->newHeight, $this->width, $this->height); $this->image = $imageResized; $this->width = $this->newWidth; $this->height = $this->newHeight; } } return $this; } public function postResize() { $this->log("### Post-process after resizing"); if ($this->rotateAfter) { $this->log("Rotating image."); $this->rotate($this->rotateAfter, $this->bgColor); } if (isset($this->filters) && is_array($this->filters)) { foreach ($this->filters as $filter) { $this->log("Applying filter {$filter['type']}."); switch ($filter['argc']) { case 0: imagefilter($this->image, $filter['type']); break; case 1: imagefilter($this->image, $filter['type'], $filter['arg1']); break; case 2: imagefilter($this->image, $filter['type'], $filter['arg1'], $filter['arg2']); break; case 3: imagefilter($this->image, $filter['type'], $filter['arg1'], $filter['arg2'], $filter['arg3']); break; case 4: imagefilter($this->image, $filter['type'], $filter['arg1'], $filter['arg2'], $filter['arg3'], $filter['arg4']); break; } } } if ($this->palette) { $this->log("Converting to palette image."); $this->trueColorToPalette(); } if ($this->blur) { $this->log("Blur."); $this->blurImage(); } if ($this->emboss) { $this->log("Emboss."); $this->embossImage(); } if ($this->sharpen) { $this->log("Sharpen."); $this->sharpenImage(); } if ($this->convolve) { $this->imageConvolution(); } return $this; } public function rotate($angle, $bgColor) { $this->log("Rotate image " . $angle . " degrees with filler color."); $color = $this->getBackgroundColor(); $this->image = imagerotate($this->image, $angle, $color); $this->width = imagesx($this->image); $this->height = imagesy($this->image); $this->log("New image dimension width x height: " . $this->width . " x " . $this->height); return $this; } public function rotateExif() { if (!in_array($this->fileType, array(IMAGETYPE_JPEG, IMAGETYPE_TIFF_II, IMAGETYPE_TIFF_MM))) { $this->log("Autorotate ignored, EXIF not supported by this filetype."); return $this; } $exif = exif_read_data($this->pathToImage); if (!empty($exif['Orientation'])) { switch ($exif['Orientation']) { case 3: $this->log("Autorotate 180."); $this->rotate(180, $this->bgColor); break; case 6: $this->log("Autorotate -90."); $this->rotate(-90, $this->bgColor); break; case 8: $this->log("Autorotate 90."); $this->rotate(90, $this->bgColor); break; default: $this->log("Autorotate ignored, unknown value as orientation."); } } else { $this->log("Autorotate ignored, no orientation in EXIF."); } return $this; } public function trueColorToPalette() { $img = imagecreatetruecolor($this->width, $this->height); $bga = imagecolorallocatealpha($img, 0, 0, 0, 127); imagecolortransparent($img, $bga); imagefill($img, 0, 0, $bga); imagecopy($img, $this->image, 0, 0, 0, 0, $this->width, $this->height); imagetruecolortopalette($img, false, 255); imagesavealpha($img, true); if (imageistruecolor($this->image)) { $this->log("Matching colors with true color image."); imagecolormatch($this->image, $img); } $this->image = $img; } public function sharpenImage() { $this->imageConvolution('sharpen'); return $this; } public function embossImage() { $this->imageConvolution('emboss'); return $this; } public function blurImage() { $this->imageConvolution('blur'); return $this; } public function createConvolveArguments($expression) { if (isset($this->convolves[$expression])) { $expression = $this->convolves[$expression]; } $part = explode(',', $expression); $this->log("Creating convolution expressen: $expression"); if (count($part) != 11) { throw new Exception( "Missmatch in argument convolve. Expected comma-separated string with
                11 float values. Got $expression." ); } array_walk($part, function ($item, $key) { if (!is_numeric($item)) { throw new Exception("Argument to convolve expression should be float but is not."); } }); return array( array( array($part[0], $part[1], $part[2]), array($part[3], $part[4], $part[5]), array($part[6], $part[7], $part[8]), ), $part[9], $part[10], ); } public function addConvolveExpressions($options) { $this->convolves = array_merge($this->convolves, $options); return $this; } public function imageConvolution($options = null) { $options = $options ? $options : $this->convolve; $this->log("Convolution with '$options'"); $options = explode(":", $options); foreach ($options as $option) { list($matrix, $divisor, $offset) = $this->createConvolveArguments($option); imageconvolution($this->image, $matrix, $divisor, $offset); } return $this; } public function setDefaultBackgroundColor($color) { $this->log("Setting default background color to '$color'."); if (!(strlen($color) == 6 || strlen($color) == 8)) { throw new Exception( "Background color needs a hex value of 6 or 8
                digits. 000000-FFFFFF or 00000000-FFFFFF7F.
                Current value was: '$color'." ); } $red = hexdec(substr($color, 0, 2)); $green = hexdec(substr($color, 2, 2)); $blue = hexdec(substr($color, 4, 2)); $alpha = (strlen($color) == 8) ? hexdec(substr($color, 6, 2)) : null; if (($red < 0 || $red > 255) || ($green < 0 || $green > 255) || ($blue < 0 || $blue > 255) || ($alpha < 0 || $alpha > 127) ) { throw new Exception( "Background color out of range. Red, green blue
                should be 00-FF and alpha should be 00-7F.
                Current value was: '$color'." ); } $this->bgColor = strtolower($color); $this->bgColorDefault = array( 'red' => $red, 'green' => $green, 'blue' => $blue, 'alpha' => $alpha ); return $this; } private function getBackgroundColor($img = null) { $img = isset($img) ? $img : $this->image; if ($this->bgColorDefault) { $red = $this->bgColorDefault['red']; $green = $this->bgColorDefault['green']; $blue = $this->bgColorDefault['blue']; $alpha = $this->bgColorDefault['alpha']; if ($alpha) { $color = imagecolorallocatealpha($img, $red, $green, $blue, $alpha); } else { $color = imagecolorallocate($img, $red, $green, $blue); } return $color; } else { return 0; } } private function createImageKeepTransparency($width, $height) { $this->log("Creating a new working image width={$width}px, height={$height}px."); $img = imagecreatetruecolor($width, $height); imagealphablending($img, false); imagesavealpha($img, true); $index = $this->image ? imagecolortransparent($this->image) : -1; if ($index != -1) { imagealphablending($img, true); $transparent = imagecolorsforindex($this->image, $index); $color = imagecolorallocatealpha($img, $transparent['red'], $transparent['green'], $transparent['blue'], $transparent['alpha']); imagefill($img, 0, 0, $color); $index = imagecolortransparent($img, $color); $this->Log("Detected transparent color = " . implode(", ", $transparent) . " at index = $index"); } elseif ($this->bgColorDefault) { $color = $this->getBackgroundColor($img); imagefill($img, 0, 0, $color); $this->Log("Filling image with background color."); } return $img; } public function setPostProcessingOptions($options) { if (isset($options['jpeg_optimize']) && $options['jpeg_optimize']) { $this->jpegOptimizeCmd = $options['jpeg_optimize_cmd']; } else { $this->jpegOptimizeCmd = null; } if (array_key_exists("png_lossy", $options) && $options['png_lossy'] !== false) { $this->pngLossy = $options['png_lossy']; $this->pngLossyCmd = $options['png_lossy_cmd']; } else { $this->pngLossyCmd = null; } if (isset($options['png_filter']) && $options['png_filter']) { $this->pngFilterCmd = $options['png_filter_cmd']; } else { $this->pngFilterCmd = null; } if (isset($options['png_deflate']) && $options['png_deflate']) { $this->pngDeflateCmd = $options['png_deflate_cmd']; } else { $this->pngDeflateCmd = null; } return $this; } protected function getTargetImageExtension() { if (isset($this->extension)) { return strtolower($this->extension); } elseif ($this->fileType === IMG_WEBP) { return "webp"; } return substr(image_type_to_extension($this->fileType), 1); } public function save($src = null, $base = null, $overwrite = true) { if (isset($src)) { $this->setTarget($src, $base); } if ($overwrite === false && is_file($this->cacheFileName)) { $this->Log("Not overwriting file since its already exists and \$overwrite if false."); return; } is_writable($this->saveFolder) or $this->raiseError('Target directory is not writable.'); $type = $this->getTargetImageExtension(); $this->Log("Saving image as " . $type); switch($type) { case 'jpeg': case 'jpg': $this->Log("Saving image as JPEG to cache using quality = {$this->quality}."); imagejpeg($this->image, $this->cacheFileName, $this->quality); if ($this->jpegOptimizeCmd) { if ($this->verbose) { clearstatcache(); $this->log("Filesize before optimize: " . filesize($this->cacheFileName) . " bytes."); } $res = array(); $cmd = $this->jpegOptimizeCmd . " -outfile $this->cacheFileName $this->cacheFileName"; exec($cmd, $res); $this->log($cmd); $this->log($res); } break; case 'gif': $this->Log("Saving image as GIF to cache."); imagegif($this->image, $this->cacheFileName); break; case 'webp': $this->Log("Saving image as WEBP to cache using quality = {$this->quality}."); imagewebp($this->image, $this->cacheFileName, $this->quality); break; case 'png': default: $this->Log("Saving image as PNG to cache using compression = {$this->compress}."); imagealphablending($this->image, false); imagesavealpha($this->image, true); imagepng($this->image, $this->cacheFileName, $this->compress); $lossyEnabled = $this->pngLossy === true; $lossySoftEnabled = $this->pngLossy === null; $lossyActiveEnabled = $this->lossy === true; if ($lossyEnabled || ($lossySoftEnabled && $lossyActiveEnabled)) { if ($this->verbose) { clearstatcache(); $this->log("Lossy enabled: $lossyEnabled"); $this->log("Lossy soft enabled: $lossySoftEnabled"); $this->Log("Filesize before lossy optimize: " . filesize($this->cacheFileName) . " bytes."); } $res = array(); $cmd = $this->pngLossyCmd . " $this->cacheFileName $this->cacheFileName"; exec($cmd, $res); $this->Log($cmd); $this->Log($res); } if ($this->pngFilterCmd) { if ($this->verbose) { clearstatcache(); $this->Log("Filesize before filter optimize: " . filesize($this->cacheFileName) . " bytes."); } $res = array(); $cmd = $this->pngFilterCmd . " $this->cacheFileName"; exec($cmd, $res); $this->Log($cmd); $this->Log($res); } if ($this->pngDeflateCmd) { if ($this->verbose) { clearstatcache(); $this->Log("Filesize before deflate optimize: " . filesize($this->cacheFileName) . " bytes."); } $res = array(); $cmd = $this->pngDeflateCmd . " $this->cacheFileName"; exec($cmd, $res); $this->Log($cmd); $this->Log($res); } break; } if ($this->verbose) { clearstatcache(); $this->log("Saved image to cache."); $this->log(" Cached image filesize: " . filesize($this->cacheFileName) . " bytes."); $this->log(" imageistruecolor() : " . (imageistruecolor($this->image) ? 'true' : 'false')); $this->log(" imagecolorstotal() : " . imagecolorstotal($this->image)); $this->log(" Number of colors in image = " . $this->ColorsTotal($this->image)); $index = imagecolortransparent($this->image); $this->log(" Detected transparent color = " . ($index > 0 ? implode(", ", imagecolorsforindex($this->image, $index)) : "NONE") . " at index = $index"); } return $this; } public function convert2sRGBColorSpace($src, $dir, $cache, $iccFile, $useCache = true) { if ($this->verbose) { $this->log("# Converting image to sRGB colorspace."); } if (!class_exists("Imagick")) { $this->log(" Ignoring since Imagemagick is not installed."); return false; } $this->setSaveFolder($cache) ->setSource($src, $dir) ->generateFilename(null, false, 'srgb_'); if ($useCache && is_readable($this->cacheFileName)) { $fileTime = filemtime($this->pathToImage); $cacheTime = filemtime($this->cacheFileName); if ($fileTime <= $cacheTime) { $this->log(" Using cached version: " . $this->cacheFileName); return $this->cacheFileName; } } if (is_writable($this->saveFolder)) { $image = new Imagick($this->pathToImage); $colorspace = $image->getImageColorspace(); $this->log(" Current colorspace: " . $colorspace); $profiles = $image->getImageProfiles('*', false); $hasICCProfile = (array_search('icc', $profiles) !== false); $this->log(" Has ICC color profile: " . ($hasICCProfile ? "YES" : "NO")); if ($colorspace != Imagick::COLORSPACE_SRGB || $hasICCProfile) { $this->log(" Converting to sRGB."); $sRGBicc = file_get_contents($iccFile); $image->profileImage('icc', $sRGBicc); $image->transformImageColorspace(Imagick::COLORSPACE_SRGB); $image->writeImage($this->cacheFileName); return $this->cacheFileName; } } return false; } public function linkToCacheFile($alias) { if ($alias === null) { $this->log("Ignore creating alias."); return $this; } if (is_readable($alias)) { unlink($alias); } $res = link($this->cacheFileName, $alias); if ($res) { $this->log("Created an alias as: $alias"); } else { $this->log("Failed to create the alias: $alias"); } return $this; } public function addHTTPHeader($type, $value) { $this->HTTPHeader[$type] = $value; } public function output($file = null, $format = null) { if (is_null($file)) { $file = $this->cacheFileName; } if (is_null($format)) { $format = $this->outputFormat; } $this->log("### Output"); $this->log("Output format is: $format"); if (!$this->verbose && $format == 'json') { header('Content-type: application/json'); echo $this->json($file); exit; } elseif ($format == 'ascii') { header('Content-type: text/plain'); echo $this->ascii($file); exit; } $this->log("Outputting image: $file"); clearstatcache(); $lastModified = filemtime($file); $lastModifiedFormat = "D, d M Y H:i:s"; $gmdate = gmdate($lastModifiedFormat, $lastModified); if (!$this->verbose) { $header = "Last-Modified: $gmdate GMT"; header($header); $this->fastTrackCache->addHeader($header); $this->fastTrackCache->setLastModified($lastModified); } foreach ($this->HTTPHeader as $key => $val) { $header = "$key: $val"; header($header); $this->fastTrackCache->addHeader($header); } if (isset($_SERVER['HTTP_IF_MODIFIED_SINCE']) && strtotime($_SERVER['HTTP_IF_MODIFIED_SINCE']) == $lastModified) { if ($this->verbose) { $this->log("304 not modified"); $this->verboseOutput(); exit; } header("HTTP/1.0 304 Not Modified"); if (CIMAGE_DEBUG) { trace(__CLASS__ . " 304"); } } else { $this->loadImageDetails($file); $mime = $this->getMimeType(); $size = filesize($file); if ($this->verbose) { $this->log("Last-Modified: " . $gmdate . " GMT"); $this->log("Content-type: " . $mime); $this->log("Content-length: " . $size); $this->verboseOutput(); if (is_null($this->verboseFileName)) { exit; } } $header = "Content-type: $mime"; header($header); $this->fastTrackCache->addHeaderOnOutput($header); $header = "Content-length: $size"; header($header); $this->fastTrackCache->addHeaderOnOutput($header); $this->fastTrackCache->setSource($file); $this->fastTrackCache->writeToCache(); if (CIMAGE_DEBUG) { trace(__CLASS__ . " 200"); } readfile($file); } exit; } public function json($file = null) { $file = $file ? $file : $this->cacheFileName; $details = array(); clearstatcache(); $details['src'] = $this->imageSrc; $lastModified = filemtime($this->pathToImage); $details['srcGmdate'] = gmdate("D, d M Y H:i:s", $lastModified); $details['cache'] = basename($this->cacheFileName); $lastModified = filemtime($this->cacheFileName); $details['cacheGmdate'] = gmdate("D, d M Y H:i:s", $lastModified); $this->load($file); $details['filename'] = basename($file); $details['mimeType'] = $this->getMimeType($this->fileType); $details['width'] = $this->width; $details['height'] = $this->height; $details['aspectRatio'] = round($this->width / $this->height, 3); $details['size'] = filesize($file); $details['colors'] = $this->colorsTotal($this->image); $details['includedFiles'] = count(get_included_files()); $details['memoryPeek'] = round(memory_get_peak_usage()/1024/1024, 3) . " MB" ; $details['memoryCurrent'] = round(memory_get_usage()/1024/1024, 3) . " MB"; $details['memoryLimit'] = ini_get('memory_limit'); if (isset($_SERVER['REQUEST_TIME_FLOAT'])) { $details['loadTime'] = (string) round((microtime(true) - $_SERVER['REQUEST_TIME_FLOAT']), 3) . "s"; } if ($details['mimeType'] == 'image/png') { $details['pngType'] = $this->getPngTypeAsString(null, $file); } $options = null; if (defined("JSON_PRETTY_PRINT") && defined("JSON_UNESCAPED_SLASHES")) { $options = JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES; } return json_encode($details, $options); } public function setAsciiOptions($options = array()) { $this->asciiOptions = $options; } public function ascii($file = null) { $file = $file ? $file : $this->cacheFileName; $asciiArt = new CAsciiArt(); $asciiArt->setOptions($this->asciiOptions); return $asciiArt->createFromFile($file); } public function log($message) { if ($this->verbose) { $this->log[] = $message; } return $this; } public function setVerboseToFile($fileName) { $this->log("Setting verbose output to file."); $this->verboseFileName = $fileName; } private function verboseOutput() { $log = null; $this->log("### Summary of verbose log"); $this->log("As JSON: \n" . $this->json()); $this->log("Memory peak: " . round(memory_get_peak_usage() /1024/1024) . "M"); $this->log("Memory limit: " . ini_get('memory_limit')); $included = get_included_files(); $this->log("Included files: " . count($included)); foreach ($this->log as $val) { if (is_array($val)) { foreach ($val as $val1) { $log .= htmlentities($val1) . '<br/>'; } } else { $log .= htmlentities($val) . '<br/>'; } } if (!is_null($this->verboseFileName)) { file_put_contents( $this->verboseFileName, str_replace("<br/>", "\n", $log) ); } else { echo <<<EOD
<h1>CImage Verbose Output</h1>
<pre>{$log}</pre>
EOD;
} } private function raiseError($message) { throw new Exception($message); } } class CCache { private $path; public function setDir($path) { if (!is_dir($path)) { throw new Exception("Cachedir is not a directory."); } $this->path = $path; return $this; } public function getPathToSubdir($subdir, $create = true) { $path = realpath($this->path . "/" . $subdir); if (is_dir($path)) { return $path; } if ($create && is_writable($this->path)) { $path = $this->path . "/" . $subdir; if (mkdir($path)) { return realpath($path); } } return false; } public function getStatusOfSubdir($subdir) { $path = realpath($this->path . "/" . $subdir); $exists = is_dir($path); $res = $exists ? "exists" : "does not exist"; if ($exists) { $res .= is_writable($path) ? ", writable" : ", not writable"; } return $res; } public function removeSubdir($subdir) { $path = realpath($this->path . "/" . $subdir); if (is_dir($path)) { return rmdir($path); } return null; } } class CFastTrackCache { private $enabled = false; private $path; private $filename; private $container; public function enable($enabled) { $this->enabled = $enabled; return $this; } public function setCacheDir($path) { if (!is_dir($path)) { throw new Exception("Cachedir is not a directory."); } $this->path = rtrim($path, "/"); return $this; } public function setFilename($clear) { $query = $_GET; foreach ($clear as $value) { unset($query[$value]); } arsort($query); $queryAsString = http_build_query($query); $this->filename = md5($queryAsString); if (CIMAGE_DEBUG) { $this->container["query-string"] = $queryAsString; } return $this->filename; } public function addHeader($header) { $this->container["header"][] = $header; return $this; } public function addHeaderOnOutput($header) { $this->container["header-output"][] = $header; return $this; } public function setSource($source) { $this->container["source"] = $source; return $this; } public function setLastModified($lastModified) { $this->container["last-modified"] = $lastModified; return $this; } public function getFilename() { return $this->path . "/" . $this->filename; } public function writeToCache() { if (!$this->enabled) { return false; } if (is_dir($this->path) && is_writable($this->path)) { $filename = $this->getFilename(); return file_put_contents($filename, json_encode($this->container)) !== false; } return false; } public function output() { $filename = $this->getFilename(); if (!is_readable($filename)) { return; } $item = json_decode(file_get_contents($filename), true); if (!is_readable($item["source"])) { return; } foreach ($item["header"] as $value) { header($value); } if (isset($_SERVER["HTTP_IF_MODIFIED_SINCE"]) && strtotime($_SERVER["HTTP_IF_MODIFIED_SINCE"]) == $item["last-modified"]) { header("HTTP/1.0 304 Not Modified"); if (CIMAGE_DEBUG) { trace(__CLASS__ . " 304"); } exit; } foreach ($item["header-output"] as $value) { header($value); } if (CIMAGE_DEBUG) { trace(__CLASS__ . " 200"); } readfile($item["source"]); exit; } } set_exception_handler(function ($exception) { errorPage( "<p><b>img.php: Uncaught exception:</b> <p>" . $exception->getMessage() . "</p><pre>" . $exception->getTraceAsString() . "</pre>", 500 ); }); $configFile = __DIR__.'/'.basename(__FILE__, '.php').'_config.php'; if (is_file($configFile)) { $config = require $configFile; } elseif (!isset($config)) { $config = array(); } if (!defined("CIMAGE_DEBUG")) { define("CIMAGE_DEBUG", false); } if (!defined("CIMAGE_BUNDLE")) { if (!isset($config["autoloader"])) { die("CImage: Missing autoloader."); } require $config["autoloader"]; } $verbose = getDefined(array('verbose', 'v'), true, false); $verboseFile = getDefined('vf', true, false); verbose("img.php version = " . CIMAGE_VERSION); $status = getDefined('status', true, false); $mode = getConfig('mode', 'production'); set_time_limit(20); ini_set('gd.jpeg_ignore_warning', 1); if (!extension_loaded('gd')) { errorPage("Extension gd is not loaded.", 500); } if ($mode == 'strict') { error_reporting(0); ini_set('display_errors', 0); ini_set('log_errors', 1); $verbose = false; $status = false; $verboseFile = false; } elseif ($mode == 'production') { error_reporting(-1); ini_set('display_errors', 0); ini_set('log_errors', 1); $verbose = false; $status = false; $verboseFile = false; } elseif ($mode == 'development') { error_reporting(-1); ini_set('display_errors', 1); ini_set('log_errors', 0); $verboseFile = false; } elseif ($mode == 'test') { error_reporting(-1); ini_set('display_errors', 1); ini_set('log_errors', 0); } else { errorPage("Unknown mode: $mode", 500); } verbose("mode = $mode"); verbose("error log = " . ini_get('error_log')); $defaultTimezone = getConfig('default_timezone', null); if ($defaultTimezone) { date_default_timezone_set($defaultTimezone); } elseif (!ini_get('default_timezone')) { date_default_timezone_set('UTC'); } $pwdConfig = getConfig('password', false); $pwdAlways = getConfig('password_always', false); $pwdType = getConfig('password_type', 'text'); $pwd = get(array('password', 'pwd'), null); $passwordMatch = null; if ($pwd) { switch ($pwdType) { case 'md5': $passwordMatch = ($pwdConfig === md5($pwd)); break; case 'hash': $passwordMatch = password_verify($pwd, $pwdConfig); break; case 'text': $passwordMatch = ($pwdConfig === $pwd); break; default: $passwordMatch = false; } } if ($pwdAlways && $passwordMatch !== true) { errorPage("Password required and does not match or exists.", 403); } verbose("password match = $passwordMatch"); $allowHotlinking = getConfig('allow_hotlinking', true); $hotlinkingWhitelist = getConfig('hotlinking_whitelist', array()); $serverName = isset($_SERVER['SERVER_NAME']) ? $_SERVER['SERVER_NAME'] : null; $referer = isset($_SERVER['HTTP_REFERER']) ? $_SERVER['HTTP_REFERER'] : null; $refererHost = parse_url($referer, PHP_URL_HOST); if (!$allowHotlinking) { if ($passwordMatch) { ; verbose("Hotlinking since passwordmatch"); } elseif ($passwordMatch === false) { errorPage("Hotlinking/leeching not allowed when password missmatch.", 403); } elseif (!$referer) { errorPage("Hotlinking/leeching not allowed and referer is missing.", 403); } elseif (strcmp($serverName, $refererHost) == 0) { ; verbose("Hotlinking disallowed but serverName matches refererHost."); } elseif (!empty($hotlinkingWhitelist)) { $whitelist = new CWhitelist(); $allowedByWhitelist = $whitelist->check($refererHost, $hotlinkingWhitelist); if ($allowedByWhitelist) { verbose("Hotlinking/leeching allowed by whitelist."); } else { errorPage("Hotlinking/leeching not allowed by whitelist. Referer: $referer.", 403); } } else { errorPage("Hotlinking/leeching not allowed.", 403); } } verbose("allow_hotlinking = $allowHotlinking"); verbose("referer = $referer"); verbose("referer host = $refererHost"); $CImage = getConfig('CImage', 'CImage'); $img = new $CImage(); $img->setVerbose($verbose || $verboseFile); $CCache = getConfig('CCache', 'CCache'); $cachePath = getConfig('cache_path', __DIR__ . '/../cache/'); $cache = new $CCache(); $cache->setDir($cachePath); $useCache = getDefined(array('no-cache', 'nc'), false, true); verbose("use cache = $useCache"); $fastTrackCache = "fasttrack"; $allowFastTrackCache = getConfig('fast_track_allow', false); $CFastTrackCache = getConfig('CFastTrackCache', 'CFastTrackCache'); $ftc = new $CFastTrackCache(); $ftc->setCacheDir($cache->getPathToSubdir($fastTrackCache)) ->enable($allowFastTrackCache) ->setFilename(array('no-cache', 'nc')); $img->injectDependency("fastTrackCache", $ftc); if ($useCache && $allowFastTrackCache) { if (CIMAGE_DEBUG) { trace("img.php fast track cache enabled and used"); } $ftc->output(); } $allowRemote = getConfig('remote_allow', false); if ($allowRemote && $passwordMatch !== false) { $cacheRemote = $cache->getPathToSubdir("remote"); $pattern = getConfig('remote_pattern', null); $img->setRemoteDownload($allowRemote, $cacheRemote, $pattern); $whitelist = getConfig('remote_whitelist', null); $img->setRemoteHostWhitelist($whitelist); } $shortcut = get(array('shortcut', 'sc'), null); $shortcutConfig = getConfig('shortcut', array( 'sepia' => "&f=grayscale&f0=brightness,-10&f1=contrast,-20&f2=colorize,120,60,0,0&sharpen", )); verbose("shortcut = $shortcut"); if (isset($shortcut) && isset($shortcutConfig[$shortcut])) { parse_str($shortcutConfig[$shortcut], $get); verbose("shortcut-constant = {$shortcutConfig[$shortcut]}"); $_GET = array_merge($_GET, $get); } $srcImage = urldecode(get('src')) or errorPage('Must set src-attribute.', 404); $srcAltImage = urldecode(get('src-alt', null)); $srcAltConfig = getConfig('src_alt', null); if (empty($srcAltImage)) { $srcAltImage = $srcAltConfig; } $imagePath = getConfig('image_path', __DIR__ . '/img/'); $imagePathConstraint = getConfig('image_path_constraint', true); $validFilename = getConfig('valid_filename', '#^[a-z0-9A-Z-/_ \.:]+$#'); $remoteSource = false; $dummyEnabled = getConfig('dummy_enabled', true); $dummyFilename = getConfig('dummy_filename', 'dummy'); $dummyImage = false; preg_match($validFilename, $srcImage) or errorPage('Source filename contains invalid characters.', 404); if ($dummyEnabled && $srcImage === $dummyFilename) { $dummyImage = true; } elseif ($allowRemote && $img->isRemoteSource($srcImage)) { $remoteSource = true; } else { $pathToImage = realpath($imagePath . $srcImage); if (!is_file($pathToImage) && !empty($srcAltImage)) { $srcImage = $srcAltImage; $pathToImage = realpath($imagePath . $srcImage); preg_match($validFilename, $srcImage) or errorPage('Source (alt) filename contains invalid characters.', 404); if ($dummyEnabled && $srcImage === $dummyFilename) { $dummyImage = true; } } if (!$dummyImage) { is_file($pathToImage) or errorPage( 'Source image is not a valid file, check the filename and that a
                matching file exists on the filesystem.', 404 ); } } if ($imagePathConstraint && !$dummyImage && !$remoteSource) { $imageDir = realpath($imagePath); substr_compare($imageDir, $pathToImage, 0, strlen($imageDir)) == 0 or errorPage( 'Security constraint: Source image is not below the directory "image_path"
            as specified in the config file img_config.php.', 404 ); } verbose("src = $srcImage"); $sizeConstant = getConfig('size_constant', function () { $sizes = array( 'w1' => 613, 'w2' => 630, ); $gridColumnWidth = 30; $gridGutterWidth = 10; $gridColumns = 24; for ($i = 1; $i <= $gridColumns; $i++) { $sizes['c' . $i] = ($gridColumnWidth + $gridGutterWidth) * $i - $gridGutterWidth; } return $sizes; }); $sizes = call_user_func($sizeConstant); $newWidth = get(array('width', 'w')); $maxWidth = getConfig('max_width', 2000); if (isset($sizes[$newWidth])) { $newWidth = $sizes[$newWidth]; } if ($newWidth[strlen($newWidth)-1] == '%') { is_numeric(substr($newWidth, 0, -1)) or errorPage('Width % not numeric.', 404); } else { is_null($newWidth) or ($newWidth > 10 && $newWidth <= $maxWidth) or errorPage('Width out of range.', 404); } verbose("new width = $newWidth"); $newHeight = get(array('height', 'h')); $maxHeight = getConfig('max_height', 2000); if (isset($sizes[$newHeight])) { $newHeight = $sizes[$newHeight]; } if ($newHeight[strlen($newHeight)-1] == '%') { is_numeric(substr($newHeight, 0, -1)) or errorPage('Height % out of range.', 404); } else { is_null($newHeight) or ($newHeight > 10 && $newHeight <= $maxHeight) or errorPage('Height out of range.', 404); } verbose("new height = $newHeight"); $aspectRatio = get(array('aspect-ratio', 'ar')); $aspectRatioConstant = getConfig('aspect_ratio_constant', function () { return array( '3:1' => 3/1, '3:2' => 3/2, '4:3' => 4/3, '8:5' => 8/5, '16:10' => 16/10, '16:9' => 16/9, 'golden' => 1.618, ); }); $aspectRatios = call_user_func($aspectRatioConstant); $negateAspectRatio = ($aspectRatio[0] == '!') ? true : false; $aspectRatio = $negateAspectRatio ? substr($aspectRatio, 1) : $aspectRatio; if (isset($aspectRatios[$aspectRatio])) { $aspectRatio = $aspectRatios[$aspectRatio]; } if ($negateAspectRatio) { $aspectRatio = 1 / $aspectRatio; } is_null($aspectRatio) or is_numeric($aspectRatio) or errorPage('Aspect ratio out of range', 404); verbose("aspect ratio = $aspectRatio"); $cropToFit = getDefined(array('crop-to-fit', 'cf'), true, false); verbose("crop to fit = $cropToFit"); $backgroundColor = getConfig('background_color', null); if ($backgroundColor) { $img->setDefaultBackgroundColor($backgroundColor); verbose("Using default background_color = $backgroundColor"); } $bgColor = get(array('bgColor', 'bg-color', 'bgc'), null); verbose("bgColor = $bgColor"); $resizeStrategy = getDefined(array('no-resample'), true, false); if ($resizeStrategy) { $img->setCopyResizeStrategy($img::RESIZE); verbose("Setting = Resize instead of resample"); } $fillToFit = get(array('fill-to-fit', 'ff'), null); verbose("fill-to-fit = $fillToFit"); if ($fillToFit !== null) { if (!empty($fillToFit)) { $bgColor = $fillToFit; verbose("fillToFit changed bgColor to = $bgColor"); } $fillToFit = true; verbose("fill-to-fit (fixed) = $fillToFit"); } $keepRatio = getDefined(array('no-ratio', 'nr', 'stretch'), false, true); verbose("keep ratio = $keepRatio"); $crop = get(array('crop', 'c')); verbose("crop = $crop"); $area = get(array('area', 'a')); verbose("area = $area"); $useOriginal = getDefined(array('skip-original', 'so'), false, true); $useOriginalDefault = getConfig('skip_original', false); if ($useOriginalDefault === true) { verbose("skip original is default ON"); $useOriginal = false; } verbose("use original = $useOriginal"); $quality = get(array('quality', 'q')); $qualityDefault = getConfig('jpg_quality', null); is_null($quality) or ($quality > 0 and $quality <= 100) or errorPage('Quality out of range', 404); if (is_null($quality) && !is_null($qualityDefault)) { $quality = $qualityDefault; } verbose("quality = $quality"); $compress = get(array('compress', 'co')); $compressDefault = getConfig('png_compression', null); is_null($compress) or ($compress > 0 and $compress <= 9) or errorPage('Compress out of range', 404); if (is_null($compress) && !is_null($compressDefault)) { $compress = $compressDefault; } verbose("compress = $compress"); $saveAs = get(array('save-as', 'sa')); verbose("save as = $saveAs"); $scale = get(array('scale', 's')); is_null($scale) or ($scale >= 0 and $scale <= 400) or errorPage('Scale out of range', 404); verbose("scale = $scale"); $palette = getDefined(array('palette', 'p'), true, false); verbose("palette = $palette"); $sharpen = getDefined('sharpen', true, null); verbose("sharpen = $sharpen"); $emboss = getDefined('emboss', true, null); verbose("emboss = $emboss"); $blur = getDefined('blur', true, null); verbose("blur = $blur"); $rotateBefore = get(array('rotateBefore', 'rotate-before', 'rb')); is_null($rotateBefore) or ($rotateBefore >= -360 and $rotateBefore <= 360) or errorPage('RotateBefore out of range', 404); verbose("rotateBefore = $rotateBefore"); $rotateAfter = get(array('rotateAfter', 'rotate-after', 'ra', 'rotate', 'r')); is_null($rotateAfter) or ($rotateAfter >= -360 and $rotateAfter <= 360) or errorPage('RotateBefore out of range', 404); verbose("rotateAfter = $rotateAfter"); $autoRotate = getDefined(array('autoRotate', 'auto-rotate', 'aro'), true, false); verbose("autoRotate = $autoRotate"); $filters = array(); $filter = get(array('filter', 'f')); if ($filter) { $filters[] = $filter; } for ($i = 0; $i < 10; $i++) { $filter = get(array("filter{$i}", "f{$i}")); if ($filter) { $filters[] = $filter; } } verbose("filters = " . print_r($filters, 1)); $outputFormat = getDefined('json', 'json', null); $outputFormat = getDefined('ascii', 'ascii', $outputFormat); verbose("outputformat = $outputFormat"); if ($outputFormat == 'ascii') { $defaultOptions = getConfig( 'ascii-options', array( "characterSet" => 'two', "scale" => 14, "luminanceStrategy" => 3, "customCharacterSet" => null, ) ); $options = get('ascii'); $options = explode(',', $options); if (isset($options[0]) && !empty($options[0])) { $defaultOptions['characterSet'] = $options[0]; } if (isset($options[1]) && !empty($options[1])) { $defaultOptions['scale'] = $options[1]; } if (isset($options[2]) && !empty($options[2])) { $defaultOptions['luminanceStrategy'] = $options[2]; } if (count($options) > 3) { unset($options[0]); unset($options[1]); unset($options[2]); $characterString = implode($options); $defaultOptions['customCharacterSet'] = $characterString; } $img->setAsciiOptions($defaultOptions); } $dpr = get(array('ppi', 'dpr', 'device-pixel-ratio'), 1); verbose("dpr = $dpr"); $convolve = get('convolve', null); $convolutionConstant = getConfig('convolution_constant', array()); if ($convolve && isset($convolutionConstant)) { $img->addConvolveExpressions($convolutionConstant); verbose("convolve constant = " . print_r($convolutionConstant, 1)); } verbose("convolve = " . print_r($convolve, 1)); $upscale = getDefined(array('no-upscale', 'nu'), false, true); verbose("upscale = $upscale"); $postProcessing = getConfig('postprocessing', array( 'png_lossy' => false, 'png_lossy_cmd' => '/usr/local/bin/pngquant --force --output', 'png_filter' => false, 'png_filter_cmd' => '/usr/local/bin/optipng -q', 'png_deflate' => false, 'png_deflate_cmd' => '/usr/local/bin/pngout -q', 'jpeg_optimize' => false, 'jpeg_optimize_cmd' => '/usr/local/bin/jpegtran -copy none -optimize', )); $lossy = getDefined(array('lossy'), true, null); verbose("lossy = $lossy"); $alias = get('alias', null); $aliasPath = getConfig('alias_path', null); $validAliasname = getConfig('valid_aliasname', '#^[a-z0-9A-Z-_]+$#'); $aliasTarget = null; if ($alias && $aliasPath && $passwordMatch) { $aliasTarget = $aliasPath . $alias; $useCache = false; is_writable($aliasPath) or errorPage("Directory for alias is not writable.", 403); preg_match($validAliasname, $alias) or errorPage('Filename for alias contains invalid characters. Do not add extension.', 404); } elseif ($alias) { errorPage('Alias is not enabled in the config file or password not matching.', 403); } verbose("alias = $alias"); $cacheControl = getConfig('cache_control', null); if ($cacheControl) { verbose("cacheControl = $cacheControl"); $img->addHTTPHeader("Cache-Control", $cacheControl); } if ($dummyImage === true) { $dummyDir = $cache->getPathToSubdir("dummy"); $img->setSaveFolder($dummyDir) ->setSource($dummyFilename, $dummyDir) ->setOptions( array( 'newWidth' => $newWidth, 'newHeight' => $newHeight, 'bgColor' => $bgColor, ) ) ->setJpegQuality($quality) ->setPngCompression($compress) ->createDummyImage() ->generateFilename(null, false) ->save(null, null, false); $srcImage = $img->getTarget(); $imagePath = null; verbose("src (updated) = $srcImage"); } $srgbDefault = getConfig('srgb_default', false); $srgbColorProfile = getConfig('srgb_colorprofile', __DIR__ . '/../icc/sRGB_IEC61966-2-1_black_scaled.icc'); $srgb = getDefined('srgb', true, null); if ($srgb || $srgbDefault) { $filename = $img->convert2sRGBColorSpace( $srcImage, $imagePath, $cache->getPathToSubdir("srgb"), $srgbColorProfile, $useCache ); if ($filename) { $srcImage = $img->getTarget(); $imagePath = null; verbose("srgb conversion and saved to cache = $srcImage"); } else { verbose("srgb not op"); } } if ($status) { $text = "img.php version = " . CIMAGE_VERSION . "\n"; $text .= "PHP version = " . PHP_VERSION . "\n"; $text .= "Running on: " . $_SERVER['SERVER_SOFTWARE'] . "\n"; $text .= "Allow remote images = $allowRemote\n"; $res = $cache->getStatusOfSubdir(""); $text .= "Cache $res\n"; $res = $cache->getStatusOfSubdir("remote"); $text .= "Cache remote $res\n"; $res = $cache->getStatusOfSubdir("dummy"); $text .= "Cache dummy $res\n"; $res = $cache->getStatusOfSubdir("srgb"); $text .= "Cache srgb $res\n"; $res = $cache->getStatusOfSubdir($fastTrackCache); $text .= "Cache fasttrack $res\n"; $text .= "Alias path writable = " . is_writable($aliasPath) . "\n"; $no = extension_loaded('exif') ? null : 'NOT'; $text .= "Extension exif is $no loaded.<br>"; $no = extension_loaded('curl') ? null : 'NOT'; $text .= "Extension curl is $no loaded.<br>"; $no = extension_loaded('imagick') ? null : 'NOT'; $text .= "Extension imagick is $no loaded.<br>"; $no = extension_loaded('gd') ? null : 'NOT'; $text .= "Extension gd is $no loaded.<br>"; $text .= checkExternalCommand("PNG LOSSY", $postProcessing["png_lossy"], $postProcessing["png_lossy_cmd"]); $text .= checkExternalCommand("PNG FILTER", $postProcessing["png_filter"], $postProcessing["png_filter_cmd"]); $text .= checkExternalCommand("PNG DEFLATE", $postProcessing["png_deflate"], $postProcessing["png_deflate_cmd"]); $text .= checkExternalCommand("JPEG OPTIMIZE", $postProcessing["jpeg_optimize"], $postProcessing["jpeg_optimize_cmd"]); if (!$no) { $text .= print_r(gd_info(), 1); } echo <<<EOD
<!doctype html>
<html lang=en>
<meta charset=utf-8>
<title>CImage status</title>
<pre>$text</pre>
EOD;
exit; } if ($verboseFile) { $img->setVerboseToFile("$cachePath/log.txt"); } $hookBeforeCImage = getConfig('hook_before_CImage', null); if (is_callable($hookBeforeCImage)) { verbose("hookBeforeCImage activated"); $allConfig = $hookBeforeCImage($img, array( 'newWidth' => $newWidth, 'newHeight' => $newHeight, 'aspectRatio' => $aspectRatio, 'keepRatio' => $keepRatio, 'cropToFit' => $cropToFit, 'fillToFit' => $fillToFit, 'crop' => $crop, 'area' => $area, 'upscale' => $upscale, 'scale' => $scale, 'rotateBefore' => $rotateBefore, 'autoRotate' => $autoRotate, 'bgColor' => $bgColor, 'palette' => $palette, 'filters' => $filters, 'sharpen' => $sharpen, 'emboss' => $emboss, 'blur' => $blur, 'convolve' => $convolve, 'rotateAfter' => $rotateAfter, 'outputFormat' => $outputFormat, 'dpr' => $dpr, 'postProcessing' => $postProcessing, 'lossy' => $lossy, )); verbose(print_r($allConfig, 1)); extract($allConfig); } if ($verbose) { $query = array(); parse_str($_SERVER['QUERY_STRING'], $query); unset($query['verbose']); unset($query['v']); unset($query['nocache']); unset($query['nc']); unset($query['json']); $url1 = '?' . htmlentities(urldecode(http_build_query($query))); $url2 = '?' . urldecode(http_build_query($query)); echo <<<EOD
<!doctype html>
<html lang=en>
<meta charset=utf-8>
<title>CImage verbose output</title>
<style>body{background-color: #ddd}</style>
<a href=$url1><code>$url1</code></a><br>
<img src='{$url1}' />
<pre id="json"></pre>
<script src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
<script type="text/javascript">
window.getDetails = function (url, id) {
  $.getJSON(url, function(data) {
    element = document.getElementById(id);
    element.innerHTML = "filename: " + data.filename + "\\nmime type: " + data.mimeType + "\\ncolors: " + data.colors + "\\nsize: " + data.size + "\\nwidth: " + data.width + "\\nheigh: " + data.height + "\\naspect-ratio: " + data.aspectRatio + ( data.pngType ? "\\npng-type: " + data.pngType : '');
  });
}
</script>
<script type="text/javascript">window.getDetails("{$url2}&json", "json")</script>
EOD;
} $img->log("Incoming arguments: " . print_r(verbose(), 1)) ->setSaveFolder($cachePath) ->useCache($useCache) ->setSource($srcImage, $imagePath) ->setOptions( array( 'newWidth' => $newWidth, 'newHeight' => $newHeight, 'aspectRatio' => $aspectRatio, 'keepRatio' => $keepRatio, 'cropToFit' => $cropToFit, 'fillToFit' => $fillToFit, 'crop' => $crop, 'area' => $area, 'upscale' => $upscale, 'scale' => $scale, 'rotateBefore' => $rotateBefore, 'autoRotate' => $autoRotate, 'bgColor' => $bgColor, 'palette' => $palette, 'filters' => $filters, 'sharpen' => $sharpen, 'emboss' => $emboss, 'blur' => $blur, 'convolve' => $convolve, 'rotateAfter' => $rotateAfter, 'outputFormat' => $outputFormat, 'dpr' => $dpr, 'lossy' => $lossy, ) ) ->loadImageDetails() ->initDimensions() ->calculateNewWidthAndHeight() ->setSaveAsExtension($saveAs) ->setJpegQuality($quality) ->setPngCompression($compress) ->useOriginalIfPossible($useOriginal) ->generateFilename($cachePath) ->useCacheIfPossible($useCache) ->load() ->preResize() ->resize() ->postResize() ->setPostProcessingOptions($postProcessing) ->save() ->linkToCacheFile($aliasTarget) ->output(); 